// Generated by PeakRDL-pss

//import std_pkg::*;
import addr_reg_pkg::*;


struct fwperiph_dma_csr : packed_s<> {
    bit[1] pause;
}

struct fwperiph_dma_int_msk_a : packed_s<> {
    bit[32] mask;
}

struct fwperiph_dma_int_msk_b : packed_s<> {
    bit[32] mask;
}

struct fwperiph_dma_int_src_a : packed_s<> {
    bit[32] source;
}

struct fwperiph_dma_int_src_b : packed_s<> {
    bit[32] source;
}

struct fwperiph_dma_channel_csr : packed_s<> {
    bit[1] en;
    bit[1] dst_sel;
    bit[1] src_sel;
    bit[1] inc_dst;
    bit[1] inc_src;
    bit[1] mode;
    bit[1] ars;
    bit[1] use_ed;
    bit[1] sz_wb;
    bit[1] stop;
    bit[1] busy;
    bit[1] done;
    bit[1] err;
    bit[3] pri;
}

struct fwperiph_dma_channel_sz : packed_s<> {
    bit[12] tot_sz;
    bit[4] reserved;
    bit[9] chk_sz;
}

struct fwperiph_dma_channel_addr : packed_s<> {
    bit[2] reserved;
    bit[30] addr;
}

struct fwperiph_dma_channel_mask : packed_s<> {
    bit[4] reserved;
    bit[28] mask;
}

struct fwperiph_dma_channel_desc : packed_s<> {
    bit[2] reserved;
    bit[30] desc;
}

struct fwperiph_dma_channel_swptr : packed_s<> {
    bit[2] reserved;
    bit[29] swptr;
    bit[1] swptr_en;
}

component fwperiph_dma_channel : reg_group_c {
    reg_c<fwperiph_dma_channel_csr,READWRITE,32> CSR;
    reg_c<fwperiph_dma_channel_sz,READWRITE,32> SZ;
    reg_c<fwperiph_dma_channel_addr,READWRITE,32> SRC_ADDR;
    reg_c<fwperiph_dma_channel_mask,READWRITE,32> SRC_MASK;
    reg_c<fwperiph_dma_channel_addr,READWRITE,32> DST_ADDR;
    reg_c<fwperiph_dma_channel_mask,READWRITE,32> DST_MASK;
    reg_c<fwperiph_dma_channel_desc,READWRITE,32> DESC;
    reg_c<fwperiph_dma_channel_swptr,READWRITE,32> SWPTR;

    pure function bit[64] get_offset_of_instance(string name) {
        if (name == "CSR") {
            return 0;
        } else if (name == "SZ") {
            return 4;
        } else if (name == "SRC_ADDR") {
            return 8;
        } else if (name == "SRC_MASK") {
            return 12;
        } else if (name == "DST_ADDR") {
            return 16;
        } else if (name == "DST_MASK") {
            return 20;
        } else if (name == "DESC") {
            return 24;
        } else if (name == "SWPTR") {
            return 28;
        } else {
            return 0;
        }
    }

    pure function bit[64] get_offset_of_instance_array(string name, int index) {
        return 0;
    }
} // end-regblock

component fwperiph_dma_map : reg_group_c {
    reg_c<fwperiph_dma_csr,READWRITE,32> csr;
    reg_c<fwperiph_dma_int_msk_a,READWRITE,32> int_msk_a;
    reg_c<fwperiph_dma_int_msk_b,READWRITE,32> int_msk_b;
    reg_c<fwperiph_dma_int_src_a,READWRITE,32> int_src_a;
    reg_c<fwperiph_dma_int_src_b,READWRITE,32> int_src_b;
    fwperiph_dma_channel channels[32];

    pure function bit[64] get_offset_of_instance(string name) {
        if (name == "csr") {
            return 0;
        } else if (name == "int_msk_a") {
            return 4;
        } else if (name == "int_msk_b") {
            return 8;
        } else if (name == "int_src_a") {
            return 12;
        } else if (name == "int_src_b") {
            return 16;
        } else if (name == "channels") {
            return 32;
        } else {
            return 0;
        }
    }

    pure function bit[64] get_offset_of_instance_array(string name, int index) {
        if (name == "channels") {
            return (index*32);
        } else {
            return 0;
        }
    }
}
